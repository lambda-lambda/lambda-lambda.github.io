<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="文档：1.6 Elements of Programming参考：cs61a.org/spring2017   1.6 高阶函数我们已经看到，函数是一种抽象方法，它用于描述独立于它们的参数的复合运算。比如函数square，12&amp;gt;&amp;gt;&amp;gt; def square(x):        return x * x 我们不是在谈论特定值的平方，而是在讨论一个能获得任何数值平方数的方法。 当然">
<meta property="og:type" content="article">
<meta property="og:title" content="SICP 第一章 使用函数抽象概念 1.6 高阶函数">
<meta property="og:url" content="http://yoursite.com/2018/01/20/post1-6/index.html">
<meta property="og:site_name" content="lambda-lambda">
<meta property="og:description" content="文档：1.6 Elements of Programming参考：cs61a.org/spring2017   1.6 高阶函数我们已经看到，函数是一种抽象方法，它用于描述独立于它们的参数的复合运算。比如函数square，12&amp;gt;&amp;gt;&amp;gt; def square(x):        return x * x 我们不是在谈论特定值的平方，而是在讨论一个能获得任何数值平方数的方法。 当然">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-a520ca96ba95efdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-33b8da949d4ab775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-a7f4aa7d3f9ebddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-cdf239ae03cc9c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-40c77b83965eef67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-cec55f795a248c94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-cf3a04953cf6d748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-efbd2d3f45475738.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-97404300ccc0f1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5899832-cfc2330cfcc70731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-01-20T16:39:25.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SICP 第一章 使用函数抽象概念 1.6 高阶函数">
<meta name="twitter:description" content="文档：1.6 Elements of Programming参考：cs61a.org/spring2017   1.6 高阶函数我们已经看到，函数是一种抽象方法，它用于描述独立于它们的参数的复合运算。比如函数square，12&amp;gt;&amp;gt;&amp;gt; def square(x):        return x * x 我们不是在谈论特定值的平方，而是在讨论一个能获得任何数值平方数的方法。 当然">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5899832-a520ca96ba95efdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/20/post1-6/"/>





  <title>SICP 第一章 使用函数抽象概念 1.6 高阶函数 | lambda-lambda</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lambda-lambda</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/20/post1-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lambda-lambda">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lambda-lambda">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SICP 第一章 使用函数抽象概念 1.6 高阶函数</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-20T23:22:32+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SICP/" itemprop="url" rel="index">
                    <span itemprop="name">SICP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>文档：<a href="http://composingprograms.com/pages/16-higher-order-functions.html" target="_blank" rel="noopener">1.6 Elements of Programming</a><br>参考：<a href="https://cs61a.org/" target="_blank" rel="noopener">cs61a.org/spring2017</a></p>
</blockquote>
<hr>
<h2 id="1-6-高阶函数"><a href="#1-6-高阶函数" class="headerlink" title="1.6 高阶函数"></a>1.6 高阶函数</h2><p>我们已经看到，函数是一种抽象方法，它用于描述独立于它们的参数的复合运算。比如函数<code>square</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">        return x * x</span><br></pre></td></tr></table></figure></p>
<p>我们不是在谈论特定值的平方，而是在讨论一个能获得任何数值平方数的方法。 当然，我们可以不去定义这个函数，总是编写诸如以下的表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 * 3</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 5 * 5</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>并且永远不会明确地提到<code>square</code>。这种做法对于诸如<code>square</code>的简单计算就足够了，但是对于更复杂的例子，例如<code>abs</code>或<code>fib</code>就将变得很困难。一般来说，缺乏函数定义将使我们处于不利之地，它迫使我们始终工作在非常原始的操作层面（这个例子中是乘法）而不是在较高级别操作。我们的程序能够计算平方，但是我们的语言将缺乏表达平方概念的能力。</p>
<p>我们应从强大的编程语言中索求的事情之一，就是通过将名称分配给常用模式来构建抽象的能力。函数提供这种能力。正如我们将在下面的例子中看到的，代码中会反复出现一些常见的编程模式，但是使用一些不同函数来实现。这些模式也可以被抽象和给予名称。</p>
<p>为了将特定的常用模式表达为具名概念，我们将需要构造可以接受其他函数作为参数或将函数作为返回值的函数。操纵函数的函数称为高阶函数。本节介绍了高阶函数如何作为强大的抽象机制，极大增加了语言的表现力。</p>
<h3 id="1-6-1-作为参数的函数"><a href="#1-6-1-作为参数的函数" class="headerlink" title="1.6.1 作为参数的函数"></a>1.6.1 作为参数的函数</h3><p>以下三个函数都能计算总和。第一个函数<code>sum_naturals</code>，计算 n个自然数的和:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_naturals(n):</span><br><span class="line">        total, k = 0, 1</span><br><span class="line">        while k &lt;= n:</span><br><span class="line">            total, k = total + k, k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; sum_naturals(100)</span><br><span class="line">5050</span><br></pre></td></tr></table></figure></p>
<p>第二个函数<code>sum_cubes</code>，计算n个自然数的立方和:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum_cubes(n):</span><br><span class="line">        total, k = 0, 1</span><br><span class="line">        while k &lt;= n:</span><br><span class="line">            total, k = total + k*k*k, k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; sum_cubes(100)</span><br><span class="line">25502500</span><br></pre></td></tr></table></figure></p>
<p>第三个函数<code>pi_sum</code>,计算以下一系列项的总和:<br><img src="http://upload-images.jianshu.io/upload_images/5899832-a520ca96ba95efdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>它会慢慢收敛于<code>pi</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pi_sum(n):</span><br><span class="line">        total, k = 0, 1</span><br><span class="line">        while k &lt;= n:</span><br><span class="line">            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; pi_sum(100)</span><br><span class="line">3.1365926848388144</span><br></pre></td></tr></table></figure></p>
<p>明显地，这三个函数拥有一个相同的模式。 它们大部分是相同的，仅在函数名和用于计算被加项的k的方法有所不同。 我们可以通过填写相同模板中的槽位来生成每个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def &lt;name&gt;(n):</span><br><span class="line">    total, k = 0, 1</span><br><span class="line">    while k &lt;= n:</span><br><span class="line">        total, k = total + &lt;term&gt;(k), k + 1</span><br><span class="line">    return total</span><br></pre></td></tr></table></figure></p>
<p>这种相同模板的存在是实用抽象出现的有力证据。 这些函数中的每一个都是求和术语。 作为程序的设计者，我们希望我们的语言足够强大，以便我们可以编写一个表达求和概念的函数，而不是对特定的值进行求和。在Python里，我们可以通过使用上面所示的通用模板，将“槽位”转换为形式参数：</p>
<p>在下面的例子中，<code>summation</code>求和有两个参数，上限n以及用来计算第k次值的函数term。 我们能像使用任何函数一样使用<code>summation</code>,并简洁地表示结果。 您可以多花点时间来执行这个例子，请注意到<code>cube</code>是如何绑定到局部名称<code>term</code>上的并且如何确保<code>1 * 1 * 1 + 2 * 2 * 2 + 3 * 3 * 3 = 36</code>的计算正确的。 在此示例中，不再需要的帧会被删除以节省空间。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-33b8da949d4ab775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用`identity`函数来返回其参数，我们还可以使用完全相同的`summation`求和函数来计算自然数之和。</span><br><span class="line">&gt;&gt;&gt; def summation(n, term):</span><br><span class="line">        total, k = 0, 1</span><br><span class="line">        while k &lt;= n:</span><br><span class="line">            total, k = total + term(k), k + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; def identity(x):</span><br><span class="line">        return x</span><br><span class="line">&gt;&gt;&gt; def sum_naturals(n):</span><br><span class="line">        return summation(n, identity)</span><br><span class="line">&gt;&gt;&gt; sum_naturals(10)</span><br><span class="line">55</span><br></pre></td></tr></table></figure></p>
<p><code>summation</code>求和函数也可以直接调用，而不需要为特定序列定义另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; summation(10, square)</span><br><span class="line">385</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用我们的<code>summation</code>函数来抽象定义<code>pi_sum</code>函数。 我们传递参数<code>1e6</code>，这是<code>1 * 10 ^ 6 = 1000000</code>的简称，结果会慢慢收敛于<code>pi</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def pi_term(x):</span><br><span class="line">        return 8 / ((4*x-3) * (4*x-1))</span><br><span class="line">&gt;&gt;&gt; def pi_sum(n):</span><br><span class="line">        return summation(n, pi_term)</span><br><span class="line">&gt;&gt;&gt; pi_sum(1e6)</span><br><span class="line">3.141592153589902</span><br></pre></td></tr></table></figure></p>
<h3 id="1-6-2-作为一般方法的函数"><a href="#1-6-2-作为一般方法的函数" class="headerlink" title="1.6.2 作为一般方法的函数"></a>1.6.2 作为一般方法的函数</h3><p>我们引入用户定义函数作为抽象机制，对数值运算进行抽象以使它们独立于特定数值。对于高阶函数，我们开始寻找一种更强大的抽象类型：一些能表达一般计算方法的函数，独立于它们调用的特定函数。</p>
<p>函数的意义发生了扩展，我们求解调用表达式的环境模型也可以适度地扩展到高阶函数的情况。当用户定义函数调用参数时，形式参数将会在最新的局部帧中绑定实参（可能是函数）的值。</p>
<p>思考接下来的示例，其实现了迭代改进的一般方法，并可以来计算<a href="http://www.geom.uiuc.edu/~demo5337/s97b/art.htm" target="_blank" rel="noopener">golden ratio</a> (黄金比例)。黄金比例，通常被称为<code>phi</code>，是一个与1.6近似，经常出现在自然、艺术、和建筑中的数值。</p>
<p>迭代改进算法开始于对方程的解的<code>guess</code>（猜测值）。它重复调用<code>update</code>更新功能来改进<code>guess</code>，并调用<code>test</code>来检查当前<code>guess</code>猜测值是否“足够接近”预想的正确值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def improve(update, close, guess=1):</span><br><span class="line">        while not close(guess):</span><br><span class="line">            guess = update(guess)</span><br><span class="line">        return guess</span><br></pre></td></tr></table></figure></p>
<p><code>improve</code>改进函数是重复细化的通用表达。 它不会具体指定要解决的问题：这些细节都留给<code>update</code>更新函数和<code>close</code>关闭函数来解决。</p>
<p>黄金比例的众所周知的特性之一是可以通过反复叠加任何正数的倒数加上1来计算，而这个黄金比例属性是一个小于它平方的数字。 我们可以将这些属性表达为<code>improve</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def golden_update(guess):</span><br><span class="line">        return 1/guess + 1</span><br><span class="line">&gt;&gt;&gt; def square_close_to_successor(guess):</span><br><span class="line">        return approx_eq(guess * guess, guess + 1)</span><br></pre></td></tr></table></figure></p>
<p>以上，我们调用了<code>approx_eq</code>：如果它的参数大致相等，则返回True。 我们可以将两个数字差值的绝对值与一个很小的tolerance value(公差值)进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def approx_eq(x, y, tolerance=1e-15):</span><br><span class="line">        return abs(x - y) &lt; tolerance</span><br></pre></td></tr></table></figure></p>
<p>使用<code>golden_update</code>和<code>square_close_to_successor</code>作为参数来调用<code>improve</code>，将会计算出黄金比例的近似值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; improve(golden_update, square_close_to_successor)</span><br><span class="line">1.6180339887498951</span><br></pre></td></tr></table></figure></p>
<p>通过跟踪求值的步骤，我们可以看到结果是如何计算出来的。 首先，<code>improve</code>的局部环境被构建起来，并为<code>update</code> 、<code>test</code> 和 <code>guess</code> 这三个参数绑定值。 在<code>improve</code>的函数体中,名字<code>close</code>被绑定到<code>square_close_to_successor</code>上，用于被初始值<code>guess</code>调用。 我们继续跟踪接下来的步骤来看看计算黄金比例的具体过程。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-a7f4aa7d3f9ebddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这个例子显示了计算机科学中两个相关的重要概念。 首先，命名和函数使我们能够把复杂抽象为简单。 虽然每个函数定义都是不重要时，但是由求值过程触发的计算过程是相当复杂的。 第二，我们拥有了非常通用的求值过程, 小组件能组合成复杂的程序。理解这个过程便于我们验证和检查我们创建的程序。</p>
<p>一如以往，我们新的一般函数<code>improve</code>需要一个测试来检查其正确性。 黄金比例可以提供这样的测试，因为它也有一个精确的闭式解，我们可以将它与迭代结果进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import sqrt</span><br><span class="line">&gt;&gt;&gt; phi = 1/2 + sqrt(5)/2</span><br><span class="line">&gt;&gt;&gt; def improve_test():</span><br><span class="line">        approx_phi = improve(golden_update, square_close_to_successor)</span><br><span class="line">        assert approx_eq(phi, approx_phi), &apos;phi differs from its approximation&apos;</span><br><span class="line">&gt;&gt;&gt; improve_test()</span><br></pre></td></tr></table></figure></p>
<p>对于这个测试，没有反馈消息就证明是好的：在执行成功的<code>assert</code>语句之后，<code>improve_test</code>返回的是<code>None</code>。</p>
<h3 id="1-6-3-定义函数-III-嵌套定义"><a href="#1-6-3-定义函数-III-嵌套定义" class="headerlink" title="1.6.3 定义函数 III:嵌套定义"></a>1.6.3 定义函数 III:嵌套定义</h3><p>上面的例子演示了函数作为参数传递而显著提高了编程语言的效率的能力。 每个通用概念或方程都能映射为小型函数。 这种方式的一个负面后果是，全局帧会变得混乱。 另一个问题是我们被特定函数的签名所约束：<code>improve</code>的<code>update</code>参数必须只接受一个参数。 嵌套函数的定义解决了这两个问题，但要求我们重新调整环境模型。</p>
<p>让我们考虑一个新问题：计算一个数的平方根。 在编程语言中，“平方根”通常缩写为<code>sqrt</code>。 重复调用下面的更新操作会收敛于<code>a</code>的平方根：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def average(x, y):</span><br><span class="line">        return (x + y)/2</span><br><span class="line">&gt;&gt;&gt; def sqrt_update(x, a):</span><br><span class="line">        return average(x, a/x)</span><br></pre></td></tr></table></figure></p>
<p>这个带有两个参数的更新函数和<code>improve</code>不兼容（它需要接受两个参数，而不是一个参数）。我们实际上只关心最后的平方根。这些问题的解决方案是把函数放到其他定义的函数体中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure></p>
<p>像局部赋值一样，局部的<code>def</code>语句仅影响当前的局部帧。这些函数仅仅当<code>sqrt</code>求值时在作用域内。和求值过程一致, 局部的<code>def</code>语句在<code>sqrt</code>调用之前并不会求值。</p>
<p><strong>词法作用域。</strong>局部定义的函数可以访问定义作用域中的名称绑定。在此示例中，<code>sqrt_update</code>引用名称<code>a</code>，它是外层函数<code>sqrt</code>的形式参数。这种在嵌套函数中共享名称的规则称为词法作用域。最重要的是，内部函数可以访问它们被定义的环境中的名称（而不是它们被调用的位置）。</p>
<p>我们需要对我们的环境模型进行两个扩展，以实现词法作用域。</p>
<p>1.每个用户定义的函数都有父环境：它的定义所在的环境。<br>2.当用户定义的函数被调用时，其局部帧扩展于其父环境。<br>在<code>sqrt</code>之前，所有函数都是在全局环境中定义的，所以它们都关联到全局环境。相比之下，当Python运行<code>sqrt</code>的前两个子句时，它创建了与本地环境相关联的函数。在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqrt(256)</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure></p>
<p>的调用中，环境首先为<code>sqrt</code>添加一个局部帧，并为<code>sqrt_update</code>和<code>sqrt_close</code>的<code>def</code>语句求值。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-cdf239ae03cc9c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>函数值每个都有一个新的注释，我们将在现在的环境图中包含一个父级。 函数值的父项是定义该函数的环境的第一个框架。 没有父注释的功能是在全球环境中定义的。 当调用用户定义的函数时，创建的框具有与该功能相同的父级。</p>
<p>随后，<code>sqrt_update</code>的名称解析到新定义的函数上，该函数是向<code>improve</code>传入的参数。 在<code>improve</code>的函数体中，我们必须以初始值 1 调用<code>update</code>函数（绑定到<code>sqrt_update</code>）。最后这个调用创建一个<code>sqrt_update</code>的环境，该环境一开始仅包含<code>x</code>的局部帧，但是之前的<code>sqrt</code>帧仍然包含一个<code>a</code>的绑定。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-40c77b83965eef67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此求值过程最关键的部分是将<code>sqrt_update</code>的父级传输到通过调用<code>sqrt_update</code>创建的帧。这个帧也用<code>[parent = f1]</code>注释。</p>
<p><strong>扩展环境</strong>。环境可以由任意多的帧组成，总是以全局框架结束。在此<code>sqrt</code>示例之前，环境最多有两帧：局部帧和全局帧。通过调用在其他函数中定义的函数，通过嵌套的<code>def</code>语句，我们可以创建更多的帧。对<code>sqrt_update</code>调用的环境由三个帧组成：局部帧<code>sqrt_update</code>，定义<code>sqrt_update</code>的<code>sqrt</code>帧（标记为<code>f1</code>）和全局帧。</p>
<p><code>sqrt_update</code>函数体中的返回表达式可以通过跟随这一系列帧来解析值。我们可以通过查找在当前环境的名称找到绑定到该名称的第一个值。 Python首先在<code>sqrt_update</code>帧中检查 – 不存在。接下来，Python检查父帧中<code>f1</code>，并找到<code>a</code>绑定到256。</p>
<p>因此，我们意识到了Python中词法作用域的两个主要优点。</p>
<ol>
<li>局部函数的名称不会影响到定义函数外部的名称，因为局部函数名称将绑定到了定义处的当前局部环境中,而不是全局环境中。</li>
<li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境扩展于定义处的求值环境。</li>
</ol>
<p><code>sqrt_update</code>函数自带有一些数据：在定义它的环境中引用的值。因为它以这种方式“封装”信息，所以局部定义的函数通常被称为<strong>闭包</strong>。</p>
<h3 id="1-6-4-作为返回值的函数"><a href="#1-6-4-作为返回值的函数" class="headerlink" title="1.6.4 作为返回值的函数"></a>1.6.4 作为返回值的函数</h3><p>我们可以通过创建返回值本身是函数的函数提高效率。 带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍旧持有所关联的环境。 以下示例展示了这一特性。</p>
<p>在定义了许多简单函数之后，<code>composition</code>函数就是包含在我们的编程语言中的自然组合方法。 也就是说，给定两个函数<code>f(x)</code>和<code>g(x)</code>，我们可能想要定义h(x)= f(g(x))。 我们可以使用我们现有的工具来定义复合函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def compose1(f, g):</span><br><span class="line">        def h(x):</span><br><span class="line">            return f(g(x))</span><br><span class="line">        return h</span><br></pre></td></tr></table></figure></p>
<p>此示例的环境图显示了<code>f</code>和<code>g</code>是如何正确解析的，即使它们存在冲突的名称。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-cec55f795a248c94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>compose1</code>中的<code>1</code>意味着复合函数只采用单个参数。 该命名惯例不由解释器强制执行; <code>1</code>只是函数名称的一部分。</p>
<p>在这里，我们开始观察我们努力在计算的复杂模型中投入的回报。我们的环境模型不需要任何修改就能支持以这种方式返回函数的能力。</p>
<h3 id="1-6-5-例子-牛顿法"><a href="#1-6-5-例子-牛顿法" class="headerlink" title="1.6.5 例子:牛顿法"></a>1.6.5 例子:牛顿法</h3><p>这个扩展示例显示了函数返回值和局部定义如何一起工作来简明扼要地表达通常概念。我们将实现一种能广泛应用于机器学习，科学计算，硬件设计和优化的算法。</p>
<p>牛顿法是一种经典的迭代方法，用于查找使数学函数返回值为零的参数。这些值称为函数的根。找到一个函数的根通常等价于解决一些有意思的问题，例如计算平方根。</p>
<p>开始前的激励：您当然知道该如何计算平方根。不只是Python，您的手机，网络浏览器或计算器都可以为您做到这一点。然而，学习计算机科学的一部分是弄懂这些数如何计算,而且,这里展示的通用方法可以用于求解 大量方程,而不仅仅是内建于 Python 的东西。</p>
<p>牛顿的方法是一种迭代改进算法：它可以改进任何可导函数的根的推测值，这意味着它可以在任何点被直线逼近。牛顿的方法遵循这些线性近似来找到函数根。</p>
<p>想象经过点 (x, f(x)) 的一条直线,它与函数 f(x) 的曲线在这一点的斜率相同。这样的直线叫做<code>tangent</code>切线,它的斜率叫做 f 在 x 上的<code>derivative</code>导数。</p>
<p>这条直线的斜率是函数值改变量与函数参数改变量的比值。所以,按照 f(x) 除以这个斜率来 平移 x ,就会得到切线到达 0 时的 x 值。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-cf3a04953cf6d748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>函数<code>newton_update</code>表达了跟随这条切线到零的计算过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def newton_update(f, df):</span><br><span class="line">        def update(x):</span><br><span class="line">            return x - f(x) / df(x)</span><br><span class="line">        return update</span><br></pre></td></tr></table></figure></p>
<p>最后，我们可以定义基于<code>newton_update</code>（我们的迭代改进算法）的<code>find_root</code>函数和比较测试以查看f(x)是否接近0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def find_zero(f, df):</span><br><span class="line">        def near_zero(x):</span><br><span class="line">            return approx_eq(f(x), 0)</span><br><span class="line">        return improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></table></figure></p>
<p><strong>计算根</strong>.使用牛顿法，我们可以计算任意度n的根。 a的n次方根为x，使得x·x·x … x = a，其中x重复n次。 例如，</p>
<ol>
<li>64的平方根为8，因为8·8 = 64。</li>
<li>64的立方根为4，因为4·4·4 = 64。</li>
<li><p>64的六次方根是2，因为2⋅2⋅2⋅2⋅2⋅2= 64。</p>
<p>通过绘制n等于2, 3和6以及a等于64的曲线，我们可以看出以下关系。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-efbd2d3f45475738.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们首先通过定义<code>f</code>及其导数<code>df</code>来实现<code>square_root</code>。 我们从微积分中知道f(x) = x^2 - a的导数是线性函数df(x) = 2*x。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_root_newton(a):</span><br><span class="line">        def f(x):</span><br><span class="line">            return x * x- a</span><br><span class="line">        def df(x):</span><br><span class="line">            return 2 * x</span><br><span class="line">        return find_zero(f, df)</span><br><span class="line">&gt;&gt;&gt; square_root_newton(64)</span><br><span class="line">8.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下是n次方根的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power(x, n):</span><br><span class="line">        &quot;&quot;&quot;Return x * x * x * ... * x for x repeated n times.&quot;&quot;&quot;</span><br><span class="line">        product, k = 1, 0</span><br><span class="line">        while k &lt; n:</span><br><span class="line">            product, k = product * x, k + 1</span><br><span class="line">        return product</span><br><span class="line">&gt;&gt;&gt; def nth_root_of_a(n, a):</span><br><span class="line">        def f(x):</span><br><span class="line">            return power(x, n) - a</span><br><span class="line">        def df(x):</span><br><span class="line">            return n * power(x, n-1)</span><br><span class="line">        return find_zero(f, df)</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(2, 64)</span><br><span class="line">8.0</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(3, 64)</span><br><span class="line">4.0</span><br><span class="line">&gt;&gt;&gt; nth_root_of_a(6, 64)</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure></p>
<p>所有这些计算中的近似误差可以通过减少<code>approx_eq</code>的<code>tolerance</code>而降低。</p>
<p>当您尝试使用牛顿法时，请注意它不总是收敛的。<code>improve</code>的初始猜测值必须足够接近根，并且必须满足函数的各种条件。 尽管有这个缺点，牛顿法是一个能解决微分方程的强大的通用计算方法。 在现代计算机中，非常快速的对数算法和大整数除法也使用了该技巧的变体。</p>
<h3 id="1-6-6-函数柯里化"><a href="#1-6-6-函数柯里化" class="headerlink" title="1.6.6 函数柯里化"></a>1.6.6 函数柯里化</h3><p>我们可以使用高阶函数将一个接受多参数的函数转换成接受一个单一参数（最初函数的第一个参数）的函数。 具体地说，给定函数f(x，y)，我们可以定义函数g，使得g(x)(y)等价于f(x，y)。 这里，g是一个高阶函数，它接受单个参数x，并返回另一个接受单个参数y的函数。 这种转变叫做<code>currying</code>函数柯里化。<br>例如，我们可以定义一个<code>pow</code>函数的柯里化版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def curried_pow(x):</span><br><span class="line">        def h(y):</span><br><span class="line">            return pow(x, y)</span><br><span class="line">        return h</span><br><span class="line">&gt;&gt;&gt; curried_pow(2)(3)</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>一些编程语言（如Haskell）只允许函数接受单个参数的，因此程序员必须对所有多参数程序进行<code>currying</code>柯里化。 在更通用的语言（如Python）中，当我们需要只接受一个参数的函数时，currying很有用。 例如，<code>map</code>模式将单参数函数应用于一系列值。 在随后的章节中，我们将看到更多的<code>map</code>模式的例子。至于现在，我们可以在一个函数中实现这个模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def map_to_range(start, end, f):</span><br><span class="line">        while start &lt; end:</span><br><span class="line">            print(f(start))</span><br><span class="line">            start = start + 1</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用<code>map_to_range</code>和<code>curried_pow</code>来计算2的前10个幂，而不是专门写一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map_to_range(0, 10, curried_pow(2))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">512</span><br></pre></td></tr></table></figure></p>
<p>我们可以类似地使用相同的两个函数来计算其他数字的幂函数。 <code>currying</code>可以让我们做到，它不需要为我们希望计算的幂的每一个数写一个特定的函数。</p>
<p>在上面的例子中，我们手动对<code>pow</code>函数进行<code>currying</code>转换，得到<code>curried_pow</code>。 相反，我们可以定义自动化currying的函数，以及反向currying的转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def curry2(f):</span><br><span class="line">        &quot;&quot;&quot;Return a curried version of the given two-argument function.&quot;&quot;&quot;</span><br><span class="line">        def g(x):</span><br><span class="line">            def h(y):</span><br><span class="line">                return f(x, y)</span><br><span class="line">            return h</span><br><span class="line">        return g</span><br><span class="line">&gt;&gt;&gt; def uncurry2(g):</span><br><span class="line">        &quot;&quot;&quot;Return a two-argument version of the given curried function.&quot;&quot;&quot;</span><br><span class="line">        def f(x, y):</span><br><span class="line">            return g(x)(y)</span><br><span class="line">        return f</span><br><span class="line">&gt;&gt;&gt; pow_curried = curry2(pow)</span><br><span class="line">&gt;&gt;&gt; pow_curried(2)(5)</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; map_to_range(0, 10, pow_curried(2))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">512</span><br></pre></td></tr></table></figure></p>
<p><code>curry2</code>函数使用了双参数函数<code>f</code>，并返回单参数函数<code>g</code>。 当<code>g</code>接受参数<code>x</code>时，它返回一个单参数函数<code>h</code>。 当<code>h</code>接受参数<code>y</code>时，它调用了<code>f(x，y)</code>。 因此，<code>curry2(f)(x)(y)</code>等价于<code>f(x，y)</code>。 <code>uncurry2</code>函数反转<code>currying</code>变换，使得<code>uncurry2(curry2(f))</code>等效于<code>f</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; uncurry2(pow_curried)(2, 5)</span><br><span class="line">32</span><br></pre></td></tr></table></figure></p>
<h3 id="1-6-7-Lambda-表达式"><a href="#1-6-7-Lambda-表达式" class="headerlink" title="1.6.7 Lambda 表达式"></a>1.6.7 Lambda 表达式</h3><p>到目前为止，每当我们想要定义新的函数时，我们都需要给它一个名字。 但是对于其他类型的表达式，我们不需要将中间值关联到名称上。 也就是说，我们可以计算<code>a * b + c * d</code>，而不用命名子表达式<code>a * b</code>或<code>c * d</code>。 在Python中，我们可以使用<code>lambda</code>表达式创建函数，该表达式会求值为匿名函数。 <code>lambda</code>表达式是函数体具有单个返回表达式的函数,不允许出现赋值和控制语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def compose1(f, g):</span><br><span class="line">        return lambda x: f(g(x))</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过构建相应的英文句子来理解lambda表达式的结构：<br><img src="http://upload-images.jianshu.io/upload_images/5899832-97404300ccc0f1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>lambda表达式的结果称为lambda函数。 它没有内在名称（因此Python为该名称打印<lambda>），但它的行为就像任何其他函数一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; s(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure></lambda></p>
<p>在环境图示中，lambda表达式的结果也是用希腊字母λ（lambda）命名的函数。 我们的示例可以用lambda表达式表达得相当简洁紧凑。<br><img src="http://upload-images.jianshu.io/upload_images/5899832-cfc2330cfcc70731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>一些程序员发现使用lambda表达式的匿名函数更简短直接。 但是复合的lambda表达式是非常难以辨认的，尽管它们很简洁。 以下定义是正确的，但很多程序员很难理解它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; compose1 = lambda f,g: lambda x: f(g(x))</span><br></pre></td></tr></table></figure></p>
<p>一般来说，Python代码风格倾向于显式的<code>def</code>语句而不是 Lambda 表达式，但是允许它们在简单函数作为参数或返回值的情况下使用。</p>
<p>这样的风格规则只是指导; 你可以按你想要的方式进行编程。 但是,在你编写程序时,要考虑某一天可能会阅读你的程序的人们。如果你可以让你的程序更易于理解,你就帮了人们一个忙。<br>术语lambda是一个历史的偶然结果, 来源于手写的数学符号和早期打字系统限制的不兼容。</p>
<blockquote>
<p>It may seem perverse to use lambda to introduce a procedure/function. The notation goes back to Alonzo Church, who in the 1930’s started with a “hat” symbol; he wrote the square function as “ŷ . y × y”. But frustrated typographers moved the hat to the left of the parameter and changed it to a capital lambda: “Λy . y × y”; from there the capital lambda was changed to lowercase, and now we see “λy . y × y” in math books and (lambda (y) (* y y)) in Lisp.</p>
<pre><code>—Peter Norvig (norvig.com/lispy2.html)
</code></pre></blockquote>
<p>尽管它们具有不寻常的词源，lambda表达式和函数调用相应形式的语言，以及lambda演算都成为了计算机科学概念的基础,并在 Python编程社区广泛传播。 当我们在第3章研究解释器的设计时，我们将重新讨论这个话题。</p>
<h3 id="1-6-8-抽象和一等函数"><a href="#1-6-8-抽象和一等函数" class="headerlink" title="1.6.8 抽象和一等函数"></a>1.6.8 抽象和一等函数</h3><p>用户定义函数是一个关键的抽象机制，因为它们允许我们将计算的通用方法表达为编程语言中的显式元素。现在我们已经看到了高阶函数如何让我们操纵这些通用方法来创建进一步的抽象。</p>
<p>作为程序员，我们应该留意程序中的低级抽象，在它们之上构架并将其概括为更强大的抽象。这不是说应该总以最抽象的方式编写程序; 专家程序员知道如何选择适合他们任务的抽象级别。但是，重要的是能够从这些抽象的角度思考，以便我们可以在新的环境中应用它们。高阶函数的意义，在于它们使我们能够将这些抽象明确地表示为编程元素，以便像处理其他计算元素那样处理它们。</p>
<p>通常，编程语言会对计算元素被操纵的方式施加限制。具有最少限制的要素具有一等的地位。一等元素的一些“权利和特权”是：</p>
<ol>
<li>它们可以被绑定到名字。</li>
<li>它们可以作为参数传递给函数。</li>
<li>它们可以作为函数的返回值返回。</li>
<li>它们可以被包括在数据结构中。</li>
</ol>
<p>Python 总是给予函数一等地位, 所产生的表现力的收益是巨大的。</p>
<h3 id="1-6-9-函数装饰器"><a href="#1-6-9-函数装饰器" class="headerlink" title="1.6.9 函数装饰器"></a>1.6.9 函数装饰器</h3><p>Python提供了特殊的语法, 将高阶函数用作执行<code>def</code>语句的一部分,叫做装饰器。 也许最常见的例子是<code>trace</code>跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def trace(fn):</span><br><span class="line">        def wrapped(x):</span><br><span class="line">            print(&apos;-&gt; &apos;, fn, &apos;(&apos;, x, &apos;)&apos;)</span><br><span class="line">            return fn(x)</span><br><span class="line">        return wrapped</span><br><span class="line">&gt;&gt;&gt; @trace</span><br><span class="line">    def triple(x):</span><br><span class="line">        return 3 * x</span><br><span class="line">&gt;&gt;&gt; triple(12)</span><br><span class="line">-&gt;  &lt;function triple at 0x102a39848&gt; ( 12 )</span><br><span class="line">36</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，定义了一个高阶函数<code>trace</code>跟踪，它返回一个函数，该函数在调用它的参数之前执行<code>print</code>语句来输出参数。<code>triple</code>的<code>def</code>语句有一个注释，<code>@trace</code>，它影响了<code>def</code>的执行规则。 像往常一样，函数<code>triple</code>被创建。 但是，<code>triple</code>名称没有绑定在此函数上。 相反，<code>triple</code>名称绑定到新定义的<code>triple</code>上的调用<code>trace</code>的返回函数值上。 在代码中，这个装饰器相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def triple(x):</span><br><span class="line">        return 3 * x</span><br><span class="line">&gt;&gt;&gt; triple = trace(triple)</span><br></pre></td></tr></table></figure></p>
<p>在与此文本相关的项目中，装饰器用于跟踪，以及选择在命令行运行程序时要调用哪些函数。</p>
<p><strong>附加部分</strong>。 装饰器符号<code>@</code>后可以跟随一个调用表达式。 首先求解<code>@</code>之后的表达式，然后是<code>def</code>语句，最后求解出的装饰器表达式的结果被应用于新定义的函数，结果绑定到<code>def</code>声明的名称上。 如果您感兴趣的话，可以阅读Ariel Ortiz编写的<a href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html" target="_blank" rel="noopener">装饰器简短教程</a>。</p>
<p>下一节：<a href="http://www.jianshu.com/p/69081ac061d9" target="_blank" rel="noopener">SICP 第一章 使用函数抽象概念 1.7 递归函数</a></p>
<hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/20/post1-3/" rel="next" title="SICP 第一章 使用函数抽象概念 1.3 定义新函数">
                <i class="fa fa-chevron-left"></i> SICP 第一章 使用函数抽象概念 1.3 定义新函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/20/post1-7/" rel="prev" title="SICP 第一章 使用函数抽象概念 1.7 递归函数">
                SICP 第一章 使用函数抽象概念 1.7 递归函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lambda-lambda</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-高阶函数"><span class="nav-number">1.</span> <span class="nav-text">1.6 高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-作为参数的函数"><span class="nav-number">1.1.</span> <span class="nav-text">1.6.1 作为参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-作为一般方法的函数"><span class="nav-number">1.2.</span> <span class="nav-text">1.6.2 作为一般方法的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-定义函数-III-嵌套定义"><span class="nav-number">1.3.</span> <span class="nav-text">1.6.3 定义函数 III:嵌套定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-作为返回值的函数"><span class="nav-number">1.4.</span> <span class="nav-text">1.6.4 作为返回值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-5-例子-牛顿法"><span class="nav-number">1.5.</span> <span class="nav-text">1.6.5 例子:牛顿法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-6-函数柯里化"><span class="nav-number">1.6.</span> <span class="nav-text">1.6.6 函数柯里化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-7-Lambda-表达式"><span class="nav-number">1.7.</span> <span class="nav-text">1.6.7 Lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-8-抽象和一等函数"><span class="nav-number">1.8.</span> <span class="nav-text">1.6.8 抽象和一等函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-9-函数装饰器"><span class="nav-number">1.9.</span> <span class="nav-text">1.6.9 函数装饰器</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lambda-lambda</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
